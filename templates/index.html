<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bilderrahmen</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; height: 100vh; display: flex; justify-content: center; align-items: center; }
        .media-container { position: absolute; width: 100vmin; height: 100vmin; opacity: 0; transition: opacity 1.5s ease-in-out; background: #000; }
        .media-container.visible { opacity: 1; }
        img, video { width: 100%; height: 100%; object-fit: cover; display: block; }
        #brightness-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; pointer-events: none; z-index: 9999; opacity: 0; transition: opacity 2s ease-in-out; }
    </style>
</head>
<body>
    <div id="brightness-overlay"></div>
    <div id="container1" class="media-container visible"></div>
    <div id="container2" class="media-container"></div>

    <script>
        var allMedia = [];
        var playlist = [];
        var currentIndex = -1;
        var activeContainerId = 'container1';
        var latestImageId = null; // Um neue Uploads zu erkennen
        
        var config = { duration: 10, mode: 'slideshow', newest_count: 5, brightness: 100, night_mode: false };

        function fetchConfigAndImages() {
                    Promise.all([
                        fetch('/api/config').then(r => r.json()),
                        fetch('/api/images').then(r => r.json())
                    ]).then(([newConfig, newImages]) => {
                        
                        // --- NEU: Neuer Upload Check ---
                        if (newImages.length > 0) {
                            const currentTopImage = newImages[0].url;
                            if (latestImageId !== null && latestImageId !== currentTopImage) {
                                console.log("Neues Bild entdeckt! Reset.");
                                currentIndex = -1; 
                            }
                            latestImageId = currentTopImage;
                        }

                        config = newConfig;
                        allMedia = newImages;
                        
                        // --- NEU: SOFORT ALLES CACHEN (Pre-Caching) ---
                        // Das sorgt dafür, dass die Bilder verfügbar sind, BEVOR das Netz weg ist
                        cacheAllMedia(newImages);

                        updatePlaylist();
                        updateBrightness();
                    })
                    .catch(err => {
                        console.log("Offline oder API Fehler. Versuche mit vorhandenen Daten weiterzumachen.", err);
                        // Wenn fetch fehlschlägt (weil Cache leer + offline), hoffen wir, 
                        // dass wir schon Daten im Speicher hatten (allMedia)
                    });
                }

                // --- Robuste Caching Funktion ---
                async function cacheAllMedia(mediaItems) {
                    if (!('caches' in window)) return;
                    
                    // WICHTIG: Hier muss 'rahmen-cache-v3' stehen, genau wie im Service Worker!
                    const cache = await caches.open('rahmen-cache-v3');
                    
                    mediaItems.forEach(item => {
                        const url = '/static/images/' + item.url;
                        const encodedUrl = encodeURI(url);

                        cache.match(encodedUrl).then(response => {
                            if (!response) {
                                console.log("Lade herunter für Offline:", item.url);
                                cache.add(encodedUrl).catch(e => console.error("Fehler bei", item.url, e));
                            }
                        });
                    });
                }
                function updatePlaylist() {
            // Priorität 1: Eingefrorenes Bild
            if (config.forced_image) {
                // Finde das Bild in den Medien
                const forced = allMedia.find(m => m.url === config.forced_image);
                if (forced) {
                    playlist = [forced];
                    return;
                }
            }

            // Priorität 2: Modus
            if (config.mode === 'newest') {
                playlist = allMedia.slice(0, config.newest_count);
            } else {
                playlist = allMedia;
            }
        }

        function isNightTime() {
            if (!config.night_mode || !config.night_start || !config.night_end) return false;
            const now = new Date();
            const cm = now.getHours() * 60 + now.getMinutes();
            const [sH, sM] = config.night_start.split(':').map(Number);
            const [eH, eM] = config.night_end.split(':').map(Number);
            const start = sH * 60 + sM; const end = eH * 60 + eM;
            return (start < end) ? (cm >= start && cm < end) : (cm >= start || cm < end);
        }

        function updateBrightness() {
            let target = isNightTime() ? (config.night_brightness || 20) : config.brightness;
            document.getElementById('brightness-overlay').style.opacity = 1 - (target / 100);
        }

        function playNext() {
            if (playlist.length === 0) { setTimeout(playNext, 2000); return; }

            // Nächster Index (Reset auf 0 wenn Ende oder neuer Upload)
            let nextIndex = (currentIndex + 1) % playlist.length;
            if (nextIndex >= playlist.length) nextIndex = 0; // Fallback falls Playlist kürzer wurde

            // Wenn wir im "Forced" Modus sind, bleiben wir immer bei 0
            if (playlist.length === 1) nextIndex = 0;

            var item = playlist[nextIndex];
            currentIndex = nextIndex;

            var nextDiv = document.getElementById((activeContainerId === 'container1') ? 'container2' : 'container1');
            var currDiv = document.getElementById(activeContainerId);
            
            nextDiv.innerHTML = '';
            var el;
            var duration = (isNightTime() ? (config.night_duration || config.duration) : config.duration) * 1000;

            if (item.type === 'video') {
                el = document.createElement('video');
                el.src = "/static/images/" + item.url;
                el.muted = true; el.autoplay = true; el.playsInline = true;
                el.style.objectPosition = "center center"; 
                el.oncanplay = () => {
                   nextDiv.classList.add('visible'); currDiv.classList.remove('visible');
                   activeContainerId = nextDiv.id;
                   el.play().catch(e=>console.log(e));
                };
                
                // Video Loop Logik
                // Wenn Playlist nur 1 Element hat (Forced oder Newest=1) -> Loop
                if (playlist.length === 1) {
                    el.loop = true;
                    // Trotzdem ab und zu checken ob neuer Upload kam
                    setTimeout(playNext, 60000); 
                } else {
                    el.onended = playNext;
                }
                el.onerror = () => setTimeout(playNext, 1000);
            } else {
                el = document.createElement('img');
                el.src = "/static/images/" + item.url;
                el.style.objectPosition = item.focus_x + "% " + item.focus_y + "%";
                el.onload = () => {
                   nextDiv.classList.add('visible'); currDiv.classList.remove('visible');
                   activeContainerId = nextDiv.id;
                   setTimeout(playNext, duration);
                };
                el.onerror = () => setTimeout(playNext, 1000);
            }
            nextDiv.appendChild(el);
        }

        fetchConfigAndImages();
        setInterval(fetchConfigAndImages, 10000); // Check alle 10s (schneller für Instant Upload)
        setInterval(updateBrightness, 60000);
        setTimeout(playNext, 1000);

        // --- PWA / OFFLINE SUPPORT ---
        if ('serviceWorker' in navigator) {
            // Unregister old workers first to be clean
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for(let registration of registrations) {
                    // Optional: Alte Worker entfernen, falls es Probleme gab
                    // registration.unregister(); 
                }
            });

            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(reg => console.log('Service Worker v2 registriert!', reg))
                    .catch(err => console.log('Service Worker Fehler:', err));
            });
        }
    </script>
</body>
</html>